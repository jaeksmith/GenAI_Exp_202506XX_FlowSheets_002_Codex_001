Here's the initial info--[Abstract]This will be a local website use create/and interact with state based work-flows that represent and allow interactions with the current state(s).These will be used, for example, to track dev project mod processes - but the site should be generic enough to represent various workflows.(The site will allow creating of templates instances of which can be spawned as new workflows use to track actual projects).The type of workflow should be based on designable templates - the user could create new instances of the template to start a new work instance.The interface will be web based, but will be a visual editing tool - point and click, drag-and-drop esque, where possible.  It's meanUsers will login to observe current state to allowing them to quickly ascertain where a give project is at / what's needed next / where things are currently at.States will include detail aspects that the code can either directly check for - such as seeing if there's a tag in SVN for the project version - thus the worksheet would auto update based on changes.The user might override state as well as will have to interact with certain aspects that are user performed.The interface will highlight changed states/aspects/etc since since that last user-acceptance - the user will accept any or all of these (whole workstate sheet) to move forwards.[Misc Notes to Integrate]This will be a web based app.The user will login to identify theirself and to provide security.  Security should be implemented as a replaceable module - initially lets just have a file base security listing users with password hashes and a list of roles.(Please setup an initial file with jaek and password (hash) test so we can login as that user).When the logs in, they should have a searchable list of the worksheets they have access to as well as a searchable list of templates.  The user should be able to double click to open either of these for editing.They should be able to right-click on these to get a context/op menu on each - this would include open, rename, copy, delete (with confirm).Template items would also have a create-instance - that creates a worksheet instance from the template.Worksheet items should have a create-template that creates a template instance form the worksheet.(Templates will really just be worksheets that ideally don't actually keep active state).Whether interactive with a template or worksheet, the user can modify the state diagram - adding/modding (name, aspects)/linking (directional-next)/delinking nodes/removing nodes/links, etc.These notes might be presetup - though that might be a later step we add - e.g. node templates - or new (which we should support right away).(These type of edits are more for template - lets may require a mode switch on the workspace - where edits require edit mode - mebbe change background color based on mode as well as some visual indicator when in edit mode).There should be basic nodes that can have aspects added/modded/removed.There should be a sub-workflow node that links to another workflow instance that can be openned in a separate view (web page (tab/window))The should be an asyn splitting node that allow parallel nodes to be active as well as merging nodes.Aspects might not be the best name - feel free to pick a better name - but let me know.  These are really checks for aspects of a given node that need to be aggregately completed in order for the node to be considered complete.(Nodes dependent on other nodes would ideally require them to be complete before they appear active - though the aspect checks in any node might be complete - whether auto or manually at any time - nodes can also be set to The aspects of a given state should be plugable - e.g. there should be an interface that such implemetnThe user might override auto-set states or aspect - like making an items as done, even if the auto-check fails - or bypass if it might be skipped - or hold-for-manual handling.Initially aspects should include-- a simple done-checkbox item.- an svn tag (location) checking node that is auto-checked if the tag is found - this should support regex in the URL - so it would need to get up to the fixed portion of the URL, then check for matched regex subpath portion, and navigate down the path recursively thus - possibly checking multiple branches if such exist - though it shoudl expect only one final target. (ideally indicating an error state visibly if there are multiple - so ideally it would indicate not found, found not yet accepted, accepted, error).  (once accepted it should store the matched path and only verify that unless the user resets state, etc)All aspects must be complete before (whether auto-found-to be complet, manually set as succes, or manually set as bypassed) for the node to be considered complete - unless a user manually marks it as complete - note that complete is different from than accepted (same for bypassed).(Manual set states should be persisted - e.g. not reset - unless the user effects this - there should be some visual indicator that the state was manually set and/or whether the state matches, etc).A worksheet should have some type of config table that includes values usable by various items.This config table should be some type of component on the worksheet surface itself.Template should be able to pre-define names and values and these should be addable, editable, removable - they should include a variable name, value.Values here and in other text entries should be able to reference the variables - thus we might have a 'ProjectShortName' 'ProjectVersion' value set, then we might have an 'ProjectSvnUrlTemplate' that has a 'https://server/path/to/${ProjectShortName}/tags/${ProjectVersion}_*'The user or multiple users might pull up the same view such that there are multiple client views of the workspace.  Any state/changes made to a given view should be visible across instances of the view.There should be some area - say another component on the worksheet itself - that shows the various users viewing current viewing or editing the workspace.  (Edit/Interact/View mode should be local, but this view tool would indicate which mode each user is in).These component should be movable just like the workflow nodes.Connecting between workflow nodes should be directional and multiple should be possible from or two any give node.  In edit mode there should be a grab tag (mebbe a circle off the side) that one can easily drag to another node to create connections -in this case they'd click drag and release.  (If they release not on a node it should drop (not create) the new connection)(It should be possible to right click and select create connection which would then allow the user to drag to the target node - in this case they'd click the target to complete the connect or do any other input to cancel - press escape, click not on a node, right click).The interface should indicate/highlight various things that have changed since the user last accepted the state - these should remain till the user again accepts the state.The workflow should recheck on open as well as mebbe every so often ... the user should be able to request the workflow recheck via quick function.Such functions should be available on a right-click on worksheet surface menu ...There should also be a button component that can be assigned to call a target function on a target object - so the button could be assigned to the worksheet and assigned the recheck function.This would be setup-able in edit mode - the target object should present it's callable functions - so ideally, during edit, we drag a link and on drop it would get the list of methods from the target and allow the user to pick.  In this case the link should appear different (color and visual if possible) than those between nodes and should, by default, only be visisble in edit mode - the method to call should be text written over the link.(So note that there should definitely extended / alt visuals when in edit mode ... and also alt or extra menu items...)Workflows persisted, shared, multi-edited live.  Storage in formatted so it can be analyzed by humans.The persisted state of formats the application create should be human editable - for example, use json where it can be used (instead of binary formats) - for example for worksheet storage.The worksheets should have a history - both item on worksheet and worksheet versions - though this might be achieved via storage in a repository.  (Perhaps manual ~commit allowed, but also commmit on worksheet acceptance?)There should be an activity log that is reparseable so we can display this - including noting modding user, time, description of mods made.It should be possible to undo - ideally via a history component that appears on the worksheet - with undo/redo buttons - showing at least a recent list of changes...The items that can be placed on the worksheet should be pluggable - e.g. so we can add extra later defined items - they must including defining display (visuals/interactions), local-editing, actions, peristing and loading, and other aspects.The application should provide a web-service interface that allows both scripts and generative AI to interact - would this provide an MCP interface directory or would that be an adapater?This interface should include being able to retrieve/review as well as be notified of various levels of activities.  (At some point want to integrate/provide gen-ai agent interactions - that will be a later phase, but the design should support).These interfaces should be abstracted from the internal storage and be designed to be backwards compatible if/as-much-as possible - this may not be wholly doable with significant changes - e.g. if mods require changes, then might have to break things, but we can at least try...[Code Related]Application needs a maintained specification that represents actual requirements/abilitiesApplication needs tests with the tests associated with requirements.Code needs to be human readable and maintainable by both humans an generative AI.Code should be well broken up - splitting up concerns - into easily reviewable chunks.Code should be commented will real details - less observable aspects - e.g. these should clarify the purpose of steps - helping to aid in interpretation with-respect-to requirements - this, since code implements what we need, but doesn't also reverse-specify it's reasoning.Meanwhile, variables, methos and code text should be named/written in a way that helps incidate what the variables represent and what the code is doing.